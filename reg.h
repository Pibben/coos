#include <stdint.h>

#ifndef REG_H
#define REG_H

enum {
    CPSR_MODE_USR = 0x10,
    CPSR_MODE_FIQ = 0x11,
    CPSR_MODE_IRQ = 0x12,
    CPSR_MODE_SVC = 0x13,
    CPSR_MODE_ABT = 0x17,
    CPSR_MODE_UND = 0x1B,
    CPSR_MODE_SYS = 0x1F,


    CPSR_FIQ = (1 << 6),
    CPSR_IRQ = (1 << 7),
};

enum
{
    // The GPIO registers base address.
    //GPIO_BASE = 0x20200000,
    PERIPHERAL_BASE = 0x3f000000,
    GPIO_BASE = 0x3f200000,

    SYSTEM_TIMER_BASE = (PERIPHERAL_BASE + 0x3000),
    SYSTEM_TIMER_CS = (SYSTEM_TIMER_BASE + 0x00),
    SYSTEM_TIMER_CLO = (SYSTEM_TIMER_BASE + 0x04),
    SYSTEM_TIMER_CHI = (SYSTEM_TIMER_BASE + 0x08),
    SYSTEM_TIMER_C0 = (SYSTEM_TIMER_BASE + 0x0c),
    SYSTEM_TIMER_C1 = (SYSTEM_TIMER_BASE + 0x10),
    SYSTEM_TIMER_C2 = (SYSTEM_TIMER_BASE + 0x14),
    SYSTEM_TIMER_C3 = (SYSTEM_TIMER_BASE + 0x18),

    INTERRUPT_CONTROLLER_BASE = (PERIPHERAL_BASE + 0xB200),

    IRQ_BASIC_PENDING = (INTERRUPT_CONTROLLER_BASE + 0x00),
    IRQ_PENDING_1 = (INTERRUPT_CONTROLLER_BASE + 0x04),
    IRQ_PENDING_2 = (INTERRUPT_CONTROLLER_BASE + 0x08),
    FIQ_CTRL = (INTERRUPT_CONTROLLER_BASE + 0x0C),
    ENABLE_IRQS_1 = (INTERRUPT_CONTROLLER_BASE + 0x10),
    ENABLE_IRQS_2 = (INTERRUPT_CONTROLLER_BASE + 0x14),
    ENABLE_BASIC_IRQS = (INTERRUPT_CONTROLLER_BASE + 0x18),
    DISABLE_IRQS_1 = (INTERRUPT_CONTROLLER_BASE + 0x1C),
    DISABLE_IRQS_2 = (INTERRUPT_CONTROLLER_BASE + 0x20),
    DISABLE_BASIC_IRQS = (INTERRUPT_CONTROLLER_BASE + 0x24),

    ARMTIMER_BASE = (PERIPHERAL_BASE + 0xB400),

    ARMTIMER_LOAD = (ARMTIMER_BASE + 0x00),
    ARMTIMER_VALUE = (ARMTIMER_BASE + 0x04),
    ARMTIMER_CTRL = (ARMTIMER_BASE + 0x08),
    ARMTIMER_IRQ_CLEAR = (ARMTIMER_BASE + 0x0C),
    ARMTIMER_IRQ_RAW = (ARMTIMER_BASE + 0x10),
    ARMTIMER_MASKED_IRQ = (ARMTIMER_BASE + 0x14),
    ARMTIMER_RELOAD = (ARMTIMER_BASE + 0x18),
    ARMTIMER_PREDIVIDER = (ARMTIMER_BASE + 0x1C),
    ARMTIMER_COUNTER = (ARMTIMER_BASE + 0x20),
};

//SYSTEM_TIMER_CS
enum {
    SYSTEM_TIMER_CS_M3 = (1 << 3),
    SYSTEM_TIMER_CS_M2 = (1 << 2),
    SYSTEM_TIMER_CS_M1 = (1 << 1),
    SYSTEM_TIMER_CS_M0 = (1 << 0)
};

//BASIC IRQs
enum {
    BASIC_ARM_TIMER_IRQ       = (1 << 0),
    BASIC_ARM_MAILBOX_IRQ     = (1 << 1),
    BASIC_ARM_DOORBELL_0_IRQ  = (1 << 2),
    BASIC_ARM_DOORBELL_1_IRQ  = (1 << 3),
    BASIC_GPU_0_HALTED_IRQ    = (1 << 4),
    BASIC_GPU_1_HALTED_IRQ    = (1 << 5),
    BASIC_ACCESS_ERROR_1_IRQ  = (1 << 6),
    BASIC_ACCESS_ERROR_0_IRQ  = (1 << 7)
};

//ARMTIMER_CTRL:
enum {

/** @brief 0 : 16-bit counters - 1 : 23-bit counter */
    ARRMTIMER_CTRL_16BIT = ( 0 << 1 ),
    ARMTIMER_CTRL_23BIT = ( 1 << 1 ),

    ARMTIMER_CTRL_PRESCALE_1   = ( 0 << 2 ),
    ARMTIMER_CTRL_PRESCALE_16  = ( 1 << 2 ),
    ARMTIMER_CTRL_PRESCALE_256 = ( 2 << 2 ),

/** @brief 0 : Timer interrupt disabled - 1 : Timer interrupt enabled */
    ARMTIMER_CTRL_INT_ENABLE  = ( 1 << 5 ),
    ARMTIMER_CTRL_INT_DISABLE = ( 0 << 5 ),

/** @brief 0 : Timer disabled - 1 : Timer enabled */
    ARMTIMER_CTRL_ENABLE  = ( 1 << 7 ),
    ARMTIMER_CTRL_DISABLE = ( 0 << 7 ),

    ARMTIMER_CTRL_CNTR_DISABLE = (0 << 9),
    ARMTIMER_CTRL_CNTR_ENABLE = (1 << 9),
};

#define REG(reg) (*(volatile uint32_t *)(reg))

enum {
    ACTLR_SMP = (1 << 6),
    SCTLR_M = (1 << 0), //MMU, also enables BP (?)
    SCTLR_C = (1 << 2), //Data and unified cache. ACTLR_SMP must be enabled.
    SCTLR_I = (1 << 12), //Instruction cache
    SCTLR_AFE = (1 << 29),
};

enum {
    CPACR_CP10_ACCESS_DENIED = (0 << 20),
    CPACR_CP10_ACCESS_P1 = (1 << 20),
    CPACR_CP10_ACCESS_ALL = (3 << 20),
    CPACR_CP11_ACCESS_DENIED = (0 << 22),
    CPACR_CP11_ACCESS_P1 = (1 << 22),
    CPACR_CP11_ACCESS_ALL = (3 << 22),

    CPACR_D32DIS = (1 << 30),
    CPACR_ASEDIS = (1 << 31),
};

enum {
    FPEXC_EN = (1 << 30),
};

#endif
